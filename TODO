
ME HE QUEDADO HACIENDO UN CROSS CHECK DE PLACES ENTRE MONGO Y TESSDB
EL QUE HAYA DUPLICADOS DE TESSDB COMPLICA BASTANTE LA COSA
ME SALEN DUPLICADOS DE TESSDB EN CROSSDB QUE NO ME SALEN CUANDO HAGO LA COMPROBACION DE TESSDB SOLO

=============================
2023-07-28 14:23:37,070 [ERROR] Coordinates (None, None) has different place names: ['LICA', 'Out of Service', 'Unknown'] for [-3, -2, -1]
2023-07-28 14:23:37,071 [ERROR] Coordinates (149.1567, -31.2737) has different place names: ['Windana', 'Castlereagh river', 'Timor Road'] for [97, 158, 159]

NOS QUEDAMOS CON EL 97
EL 158 NO TIENE REFERENCIAS ASI QUE SE PUEDE BORRAR


2023-07-28 14:23:37,071 [ERROR] Coordinates (9.160547, 50.137403) has different place names: ['Horbach', 'Hans-Nüchter-Sternwarte', 'Hans-Nüchter-Sternwarte'] for [137, 237, 331]

NOS QUEDAMOS CON EL 137
237 tiene 1 refernecia en tess_t
LOS DEMAS NO TIENEN REFERENCIAS ASI QUE SE PUEDEN BORRAR

2023-07-28 14:23:37,071 [ERROR] Coordinates (-70.955818, -29.9843) has different place names: ['Vicuña', 'D-273', 'D-273'] for [186, 227, 321]

NOS QUEDAMOS CON EL 186
LOS DEMAS NO TIENEN REFERENCIAS ASI QUE SE PUEDEN BORRAR

2023-07-28 14:23:37,071 [ERROR] Coordinates (-71.20479, -29.9255) has different place names: ['La Serena', 'Los girasoles 5427', 'Los girasoles 5427'] for [187, 246, 340]

NOS QUEDAMOS CON EL 187
LOS DEMAS NO TIENEN REFERENCIAS ASI QUE SE PUEDEN BORRAR

2) Hacer un cross-check de nombres y MACs entre MongoDB y tessdb

SELECT name, mac_address, valid_since, valid_until, valid_state
FROM name_to_mac_t
WHERE name LIKE 'stars%'
ORDER BY cast(substr(name,6) as int) ASC, valid_since ASC;

SELECT count(*), name
FROM name_to_mac_t
WHERE name LIKE 'stars%'
GROUP BY name
ORDER BY cast(substr(name,6) as int) ASC;


CREATE TEMP TABLE IF NOT EXISTS names_t (name TEXT);
INSERT INTO names_t (name) VALUES ('stars1');
INSERT INTO names_t (name) VALUES ('stars2');
INSERT INTO names_t (name) VALUES ('stars8');
INSERT INTO names_t (name) VALUES ('stars65');
INSERT INTO names_t (name) VALUES ('stars88');
INSERT INTO names_t (name) VALUES ('stars223');
INSERT INTO names_t (name) VALUES ('stars275');
INSERT INTO names_t (name) VALUES ('stars301');
INSERT INTO names_t (name) VALUES ('stars307');
INSERT INTO names_t (name) VALUES ('stars315');
INSERT INTO names_t (name) VALUES ('stars341');
INSERT INTO names_t (name) VALUES ('stars351');
COMMIT;


SELECT name, mac_address, valid_since, valid_until, valid_state
FROM name_to_mac_t
WHERE name IN (SELECT * from names_t)
ORDER BY cast(substr(name,6) as int) ASC, valid_since ASC;

SELECT t.name, t.mac_address, t.valid_since, t.valid_until, t.valid_state, p.zero_point, p.filter
FROM name_to_mac_t AS t
JOIN tess_t as p USING (mac_address)
WHERE t.name IN (SELECT * from names_t)
ORDER BY cast(substr(t.name,6) as int) ASC, t.valid_since ASC, p.valid_since ASC;


SELECT t.name, t.mac_address, 
t.valid_since AS ren_valid_since, t.valid_until AS ren_valid_until, t.valid_state AS ren_valid_state, 
p.zero_point, p.filter, 
p.valid_since AS zp_valid_since,  p.valid_until AS zp_valid_until,  p.valid_state AS zp_valid_state
FROM name_to_mac_t AS t
JOIN tess_t as p USING (mac_address)
WHERE t.name = 'stars1'
ORDER BY cast(substr(t.name,6) as int) ASC, t.valid_since ASC, p.valid_since ASC;


SELECT t.mac_address, t.name, 
t.valid_since AS ren_valid_since, t.valid_until AS ren_valid_until, t.valid_state AS ren_valid_state, 
p.zero_point, p.filter, 
p.valid_since AS zp_valid_since,  p.valid_until AS zp_valid_until,  p.valid_state AS zp_valid_state
FROM name_to_mac_t AS t
JOIN tess_t as p USING (mac_address)
WHERE t.mac_address = '18:FE:34:D3:48:CD'
ORDER BY cast(substr(t.name,6) as int) ASC, t.valid_since ASC, p.valid_since ASC;

SELECT name, valid_status FROM name_to_mac_t GROUP BY name HAVING COUNT(*) > 1;


SELECT name, mac_address, valid_state
FROM name_to_mac_t
WHERE valid_since IN (SELECT MAX(valid_since) FROM name_to_mac_t GROUP BY name)
ORDER BY cast(substr(name,6) as int) ASC, valid_since ASC;

SELECT name, mac_address, valid_state
FROM name_to_mac_t
ORDER BY cast(substr(name,6) as int) ASC, valid_since ASC;


== ANTIGUO
Retocar la utilidad de tess para mostar min(fecha), max(fecha) con reading counts y demás
en luger de la fecha metida por linea de comandos.
tess instrument coalesce --name <name> | --mac <mac> --test

SUSTITUIR TABLA
CREATE TABLE "location_t"
            (
            location_id             INTEGER PRIMARY KEY AUTOINCREMENT,  
            site                    TEXT,
            longitude               REAL,
            latitude                REAL,
            elevation               REAL,
            zipcode                 TEXT,
            location                TEXT,
            province                TEXT,
            state                   TEXT,
            country                 TEXT,
            timezone                TEXT DEFAULT 'Etc/UTC',
            contact_name            TEXT,
            contact_email           TEXT,
            organization            TEXT
            )

POR ESTA OTRA

CREATE TABLE location_t
(
    location_id             INTEGER,  
    place                   TEXT,
    longitude               REAL NOT NULL,
    latitude                REAL NOT NULL,
    masl                    REAL, -- meters above sea level
    zipcode                 TEXT,
    town                    TEXT, -- it can be a village, town, city, or municipality
    sub_region              TEXT, -- its type can be 'state_district','province'
    region                  TEXT, -- state
    country                 TEXT,
    timezone                TEXT DEFAULT 'Etc/UTC',
    contact_name            TEXT, -- still used but to be deprecated
    contact_email           TEXT, -- still used but to be deprecated
    organization            TEXT, -- stiil used but to be deprecated by organization_t

    UNIQUE(longitude, latitude),
    PRIMARY KEY(location_id) AUTOINCREMENT
)

Los campos que vayan a ser deprecados no deberian tener operaciones de create/update en la tess utility
Tabla de observer_t que tenga una referencia a la tabla organization_t
En la tabla de hechos se almacenan tanto las referencias al observador  

O BIEN

Esta tabla mixin maneja observadores que son o bien personas físicas (que pueden o no pertenecer a una organización)
o personas jurídicas (organizaciones)
Los atributos person_valid_* manejan el histórico de pertenencia de una persona a una organización

CREATE TABLE IF NOT EXISTS observer_t
(
    observer_id         INTEGER,
    obs_type            TEXT NOT NULL, -- Either 'person' or 'organization'
    -----------------------------------------------------------------------
    person_name         TEXT,      -- 
    person_surname      TEXT,      --
    person_title        TEXT,      -- 'Dr.' , 'Professor', etc. if applicable.
    -- These three manages history of a person within an organization
    person_valid_since  TIMESTAMP, -- 'YYYY-MM-DD HH:MM:SS'
    person_valid_until  TIMESTAMP, -- 'YYYY-MM-DD HH:MM:SS'
    person_valid_state  TEXT,      -- Either 'Current' or 'Expired' 
    ------------------------------------------------------------------------
    org_name            TEXT,      -- Organization name
    org_acronym         TEXT,      -- Organization acronym (i.e. AAM, UCM)
    org_description     TEXT,      -- Organization description
    org_email           TEXT,
    org_phone           TEXT,
    org_logo_url,       TEXT,      -- Organization logo URL
    org_web_url,        TEXT,      -- Organization web URL
    ------------------------------------------------------------------------
    PRIMARY KEY(observer_id)
);

